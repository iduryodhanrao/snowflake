## 🧠 Key Features

### 💬 Conversational Interface
- Built using `streamlit.chat_input` and chat memory for multi-turn interactions.
- Resets conversation context using a “Reset Chat” button and assistant intro prompt.

### 🔍 Semantic Query Generation
- Utilizes `snowflake.cortex.Complete` with `claude-3-5-sonnet` for summarization and response generation.
- Sends contextual meeting-related chat inputs to Cortex Analyst API.
- Extracts and executes SQL when relevant.

### 🧊 Snowflake Cortex Integration
- Semantic model sourced from:meeting_analysis.yaml
- - Sends structured payloads via `_snowflake.send_snow_api_request()` to generate SQL and explanations.

### 📈 Dynamic SQL Execution
- SQL generated by the model is executed using Snowpark and results displayed via `st.write()` and `st.code()`.

### 🧠 Smart Follow-up
- Displays suggestions for next steps/questions returned by the model.
- Ensures fast iteration of dialogue with meeting content.

---

## 🛠 Tech Stack

| Layer        | Technology                               |
|--------------|-------------------------------------------|
| Frontend     | Streamlit                                 |
| LLM Model    | Claude 3.5 Sonnet (via Snowflake Cortex)  |
| Backend      | Snowflake Cortex API                      |
| Runtime      | Snowpark Python                           |
| UI Enhancements | streamlit.status, streamlit.chat_message |

---

## 📦 App Flow

1. **User enters a question about a meeting.**  
2. **App summarizes chat + sends request to Cortex Analyst.**  
3. **If SQL is returned**, it is run via Snowflake + result is summarized again.  
4. **Otherwise**, direct explanation or fallback message is returned.  
5. **Suggested follow-up questions** are offered to improve discovery.

---

## ✅ Prerequisites

- Valid Snowflake account with Cortex and Analyst API access  
- Semantic model YAML file uploaded in named stage  
- Chat-ready transcript data accessible through defined Snowflake objects

---

## 🌟 Example Use Case

> *"What decisions were made about feature IS1004c?"*  
→ The app fetches context, generates semantic SQL, executes it, and provides a concise answer based on meeting insights.

---

- Samples taken from Snowflake Quickstart Guide
